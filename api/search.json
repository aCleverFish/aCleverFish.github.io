[{"id":"56f5ee9eb9d6b20a14b93644d3b4660a","title":"ASP.NET CORE 中的模型绑定","content":"ASP.NET CORE 中的模型绑定系统2022·05-16  2022 \n什么是模型绑定\n\n\n\n\n\n\n\n\nController控制器和 Razor 页面处理来自 HTTP 请求的数据。例如，路由数据可能会提供记录键，而发布的表单字段可能会提供模型属性的值。编写代码来检索每个这些值并将它们从字符串转换为 .NET 类型将是乏味且容易出错的。模型绑定使这个过程自动化。模型绑定系统：\n\n从各种来源检索数据，例如路由数据、表单字段和查询字符串。\n在方法参数和公共属性中向Controller控制器和 Razor 页面提供数据。\n将字符串数据转换为 .NET 类型。\n更新复杂类型的属性。\n\n举例假设有以下操作方法\n[HttpGet(&quot;&#123;id&#125;&quot;)] \npublic ActionResult&lt;Pet&gt; GetById(int id, bool dogsOnly)\n\n并且应用程序接受到带有此URL的请求：\nhttps:&#x2F;&#x2F;contoso.com&#x2F;api&#x2F;pets&#x2F;2?DogsOnly&#x3D;true\n\n模型绑定在路由系统选择Action方法后会经过以下步骤：\n\n找到GetById方法的第一个参数：名字为id变量类型为int\n查看在HTTP请求中可用的源数据类型并且在路由数据中找到id&#x3D;”2”\n将string类型的”2”转换成int类型\n找到GetById的下一个参数：名字为dogsOnly变量类型为bool\n查看在HTTP请求中可用的源数据类型并且在路由数据中找到DogsOnly&#x3D;”true”。名称匹配不区分大小写\n将string类型的”true”转换成bool类型的true\n\n\n\n\n\n\n\n\n\n\n在前面的示例中，模型绑定目标是简单的方法参数。目标也可能是复杂类型的属性。成功绑定每个属性后，会对该属性进行模型验证。将哪些数据绑定到模型以及任何绑定或验证错误的记录存储在ControllerBase.ModelState或PageModel.ModelState中。要确定此过程是否成功，应用程序会检查ModelState.IsValid标志。\n目标模型绑定尝试查找以下几种目标值\n\n由请求路由到控制器action的操作方法的参数\n由请求路由到Razor Pages处理程序方法的参数\nPageModel类或controller的公共属性（如果由属性指定）。\n\n[BindProperty] attribute\n\n\n\n\n\n\n\n\n\n可以应用于Controller 或 PageModel类的公共属性，让模型绑定以该属性为目标：\npublic class EditModel : PageModel\n&#123;\n    [BindProperty]\n    public Instructor? Instructor &#123; get; set; &#125;\n\n    &#x2F;&#x2F; ...\n&#125;\n\n[BindProperties] attribute\n\n\n\n\n\n\n\n\n\n可以应用于Controller或者PageModel类去告诉模型绑定目标是这个类的所有属性\n[BindProperties]\npublic class CreateModel : PageModel\n&#123;\n    public Instructor? Instructor &#123; get; set; &#125;\n\n    &#x2F;&#x2F; ...\n&#125;\n\nHTTP GET 请求的模型绑定\n\n\n\n\n\n\n\n\n默认情况下，属性未绑定到 HTTP GET 请求。通常，GET 请求只需要一个记录 ID 的参数。记录 ID 用于在数据库中查找项目。因此，无需绑定包含模型实例的属性。在您确实希望将属性绑定到来自 GET 请求的数据的情况下，请将SupportsGet属性设置为true：\n[BindProperty(Name &#x3D; &quot;ai_user&quot;, SupportsGet &#x3D; true)]\npublic string? ApplicationInsightsCookie &#123; get; set; &#125;\n\n来源默认情况\n\n\n\n\n\n\n\n\n默认情况下，模型绑定以key-value对的形式从HTTP请求中的以下来源拿到数据：\n\nForm fields - 表单域\nThe request body  - 请求体\nRoute data - 路由数据\nQuery string parameters - 查询字符串参数\nUploaded files - 上传的文件\n\n对于每个目标参数或属性，源将按照前面列表中指示的顺序进行扫描。\n\n\n\n\n\n\n\n\n\n有几个例外：\n\n路由数据和查询字符串值仅用于简单类型。\n上传的文件仅绑定到实现IFormFile接口或IEnumerable&lt;IFormFile&gt;接口的目标类型。\n\n指定来源如果默认来源不正确，那就需要使用以下特性来指定来源\n\n[[FromQuery]] 从查询字符串中获取值，\n[[FromRoute]] 从路由数据中获取值\n[[FromForm]] 从提交的表单域中获取值。\n[[FromBody]] 从请求体(请求正文)中获取值。\n[[FromHeader]] 从 HTTP 标头获取值。\n\n这些属性可：\n\n单独添加到模型属性中，而不是添加到模型类中，如下例所示\n\npublic class Instructor\n&#123;\n    public int Id &#123; get; set; &#125;\n\n    [FromQuery(Name &#x3D; &quot;Note&quot;)]\n    public string? NoteFromQueryString &#123; get; set; &#125;\n\n    &#x2F;&#x2F; ...\n&#125;\n\n\n可以选择在构造函数中接收模型名称值。如果属性名称与请求中的值不匹配，则会提供此选项。例如，请求中的值可能是名称中带有连字符的表头，如下：\n\npublic void OnGet([FromHeader(Name &#x3D; &quot;Accept-Language&quot;)] string language)\n\n实际应用从前端发送过来的请求由三个部分组成：\n\n请求URL\n请求头\n请求体[FromXXX] 就是告诉后台在哪里获取参数，分别对应以上三个部分拿到的参数\n\n\n[[FromQuery]] 从查询字符串中获取值，HttpGet请求的时候，使用实体接收参数时需要加\n[[FromRoute]] 从路由数据中获取值数据在路由(URL)中，不是那个带?和&amp;的查询字符串，如：请求某博客文档https://www.iaspnetcore.com/Blog/BlogPost/594960eb84cd453380655bc9\n[[FromForm]] 从提交的表单域中获取值。从请求体中获取数据，但是是通过Form传递的数据\n[[FromBody]] 从请求体(请求正文)中获取值。从请求体中获取数据，数据格式为来自请求体的数据[FromForm]和[FromBody]都是从body里面拿值，只不过拿到的数据类型不同\n[[FromHeader]] 从 HTTP 标头获取值。\n\n举例订货系统\n路由属性ASP.NET Core 提供了强大的Route属性。这可以用来在控制器类中定义一个顶级路由——这样做会留下一个可以扩展操作的公共路由。例如考虑以下内容：\n[Route(&quot;api&#x2F;[Controller]&quot;)]\n\npublic class OrdersController : Controller\n\n&#123;\n    [HttpGet(&quot;&#123;id&#125;&quot;)]\n\n    public Task&lt;Order&gt; Get([FromRoute] int id)&#x3D;&gt; _orderService.GetOrderAsync(id);\n\n&#125;\n\nRoute 属性给了一个”api&#x2F;[Controller]”形式的模板“[Controller]”是一种特殊的命名约定，在上下文中充当控制器的占位符，即orders。再来关注HttpGet，我们可以看到我们提供了”{id}”的模板参数，这将使HTTP Get路由像”api&#x2F;orders&#x2F;1”一样，其中id是一个变量。\nHTTP GET 请求对于HTTP GET 请求。在我们的订单集合中，每个订单都有一个唯一的标识符，我们可以通过”id”从集合中访问它。典型的RESTful风格的最佳实践，就是可以通过它的路由来检索，例如”api&#x2F;orders&#x2F;1”。处理这个请求的动作可以这样写：\n[HttpGet(&quot;api&#x2F;orders&#x2F;&#123;id&#125;&quot;)&#x2F;&#x2F; api&#x2F;orders&#x2F;7&#96;]\npublic Task&lt;Order&gt; Get([FromRoute] int id,[FromServices] IOrderService orderService)&#x3D;&gt; orderService.GetOrderAsync(id);\n\n我们只需要简单地使用HttpGet特性去装饰控制器行为(action),这个特性将会指示ASP.NET Core框架将此操作当作HTTP GET 动作处理程序并处理路由。我们提供一个端点模板作为属性的参数。模板用作框架将用于匹配传入请求的路由。在此模板中，{id}值对应于“id”参数的路由部分。这是一个Task&lt;Order&gt;返回方法，这意味着该方法的主体将表示一个异步操作，一旦等待，该操作最终会产生一个Order对象。该方法有两个参数，它们都利用了特性。首先,FromRoute属性告诉框架在路由(URL)中查找”id”对应的值并将其作为id参数提供。然后是FromServices属性,解决了IOrderService的实现。该属性向我们的依赖注入容器询问IOrderService的相应实现。该实现给orderService提供了参数。然后，定义我们的方法体为订单服务’GetOrderAsync’函数，并将相应的标识符传给他。我们也可以很容易的编写它来使用FromQuery属性。这将会告诉框架等待一个叫做”identifier”和相应整数值的查询字符串。然后该值作为id参数传递给action。其他都一样。然而大多数用法类似于FromRoute的用法，就是将标识符放到URL中。\n[HttpGet(&quot;api&#x2F;orders&quot;)]&#x2F;&#x2F; api&#x2F;orders?identifier&#x3D;7\npublic Task&lt;Order&gt; Get([FromQuery(Name &#x3D; &quot;identifier&quot;)] int id,[FromServices] IOrderService orderService)&#x3D;&gt; orderService.GetOrderAsync(id);\n\n在这种情况下,如果我们有一个URL为”api&#x2F;orders?id&#x3D;17”,框架不会给我们的id赋值为17,而是去找查询字符串中标识符为”identifier”的字段\n\nHTTP POST 请求当需要给顾客暴露一些API功能接口创建订单时,使用HttpPost请求.\n编写它的语法和我们处理伤处HTTP GET端点相同.但是使用的是IActionResult,而不是返回资源.在IActionResult中有大量子类,可以通过Controller类访问.我们可以利用一些便利的接口比如StatusCode方法.\n使用HTTP GET,请求是针对资源的;而HTTP POST 是创建资源的请求,相应的响应是POST请求的状态结果\n[HttpPost(&quot;api&#x2F;orders&quot;)]\npublic async Task&lt;IActionResult&gt; Post([FromBody] Order order) &#x3D;&gt; (await _orderService.CreateOrderAsync(order))? (IActionResult)Created($&quot;api&#x2F;orders&#x2F;&#123;order.Id&#125;&quot;, order)&#x2F;&#x2F; HTTP 201\n: StatusCode(500);&#x2F;&#x2F; HTTP 500\n\n使用HttpPost属性,提供模板参数,这里不需要模板中的”{id}”,因为我们通过HTTP POST 请求的主体获得了整个订单对象。此外,我们将需要使用async关键字来启用在方法主体中使用await关键字。\n我们有一个Task&lt;IActionResult&gt;代表我们的异步操作。order参数用[FromBody]属性修饰.此属性指示框架从HTTP POST 请求的正文中挑选订单,将其反序列化为我们的强类型C# Order类对象,并将其作为此操作的参数提供。这个方法体是一个表达式,不像在HTTP GET方法中所展示的一样,要求通过FromService属性来提供订单的服务。在这里是创建操作委托给订单服务对CtreateOrderAsync的调用，为其提供订单。该服务返回一个表示成功或失败的bool值。如果调用成功，则返回HTTP状态码201，如果调用失败，返回HTTP状态码500。除了使用[FromBody]以外，还可以使用[FromForm]来修饰order参数，使用这个方式的话拿到参数的方式就不一样了，不再是从body中拿，而是从form中拿，但其他都一样。其他的属性就不适用于Post请求了，应该避免使用。\n[HttpPost(&quot;api&#x2F;orders&quot;)]\npublic async Task&lt;IActionResult&gt;Post([FromForm] Order order)&#x3D;&gt; (await _orderService.CreateOrderAsync(order))? Ok() &#x2F;&#x2F; HTTP 200\n: StatusCode(500);\n\nHTTP PUT 请求现在，我们已经可以创建和查询订单，然后我们将能够修改他们。\nHTTP PUT 请求是幂等的。这意味着如果一个HTTP PUT 请求发生时，任何具有相同负载的后续HTTP PUT 请求都将产生相同的响应。换句话说多个相同的HTTP PUT 请求是无害的，资源仅在第一个请求时受到影响\nHTTP PUT 动词与 HTTP POST 动词非常相似，因为配对在一起的 ASP.NET Core 属性是相同的。同样，我们将利用[FromBody]或[FromForm]属性。如下：\n[HttpPut(&quot;api&#x2F;orders&#x2F;&#123;id&#125;&quot;)]\npublic async Task&lt;IActionResult&gt;Put([FromRoute] int id, [FromBody] Order order)&#x3D;&gt; (await _orderService.UpdateOrderAsync(id, order))? Ok(): StatusCode(500);\n\n在这里[FromRoute]属性提供了id参数，FromBody属性将HTTP PUT 请求正文作为我们的C# Order实例反序列化到order参数中。我们将操作表示为对订单服务的UpdateOrderAsync函数的调用，传递id和order。最后，根据我们是否能够成功更新订单——我们返回 200 或 500 的 HTTP 状态代码以表示更新失败。\nHTTP DELETE 请求最后是删除操作，它通过HTTP DELETE 请求来展示接口从路由模板的角度来看，我们从 REST 中寻找灵感并遵循其建议的模式。\nHTTP DELETE 动词与 HTTP GET 类似，我们将使用 {id} 作为路由的一部分，并在订单集合上调用 delete 调用。这将删除给定 ID 的订单。\n[HttpDelete(&quot;api&#x2F;orders&#x2F;&#123;id&#125;&quot;)]\npublic async Task&lt;IActionResult&gt;Delete([FromRoute] int id)&#x3D;&gt; (await _orderService.DeleteOrderAsync(id))? (IActionResult)Ok(): NoContent();\n\n虽然确实可以将FromQuery与 HTTP DELETE 请求一起使用，但这是非常规且不明智的。最好坚持使用FromRoute属性。\nGet和Post请求1. Get请求前端JS发送Get请求的时候，后台可以分参数接收，也可以用实体接收，但是需要在实体的前面加上[FromQuery]。 注：不能用dynamic接收，不管怎么处理都报错。案例测试　(1).分参数接收，可以正常访问。　(2).使用实体类接收，前面加[FromQuery],可以正常访问(否则报415)。　(3).用dynamic接收，前面什么不加,报错415,前面加[FromQuery]，也报错，报500。服务端代码：\n[Route(&quot;api&#x2F;[controller]&#x2F;[action]&quot;)]\n    [ApiController]\n    public class FirstController : ControllerBase\n    &#123;\n        &#x2F;**下面是测试Get请求的相关方法**&#x2F;\n        [HttpGet]\n        public string GetInfor1(string userName, string pwd)\n        &#123;\n            return $&quot;&#123;userName&#125;+&#123;pwd&#125;&quot;;\n        &#125;\n\n        [HttpGet]\n        public string GetInfor2([FromQuery]UserInfor model)\n        &#123;\n            return $&quot;&#123;model.userName&#125;+&#123;model.pwd&#125;&quot;;\n        &#125;\n        [HttpGet]\n        &#x2F;&#x2F;加上[FromQuery]也报错\n        public string GetInfor3([FromQuery]dynamic model)\n        &#123;\n            return $&quot;&#123;model.userName&#125;+&#123;model.pwd&#125;&quot;;\n        &#125;\n    &#125;\n\n前端代码：\n//一.下面是Get请求的测试\n            //1. 分参数接收，可以正常访问\n            $(\"#getBtn1\").click(function () &#123;\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/GetInfor1\", type: \"get\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, success: function (data) &#123; console.log(data); &#125; &#125;);\n            &#125;);\n            //2. 用实体类接收，前面加[FromQuery],可以正常访问(否则报415)\n            $(\"#getBtn2\").click(function () &#123;\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/GetInfor2\", type: \"get\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, success: function (data) &#123; console.log(data); &#125; &#125;);\n            &#125;);\n            //3. 用dynamic接收，前面什么不加,报错415,前面加[FromQuery]，也报错，报500\n            $(\"#getBtn3\").click(function () &#123;\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/GetInfor3\", type: \"get\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, success: function (data) &#123; console.log(data); &#125; &#125;);\n\n2. Post请求前端JS发送Post请求的时候，可能是表单提交，也可能是JOSN格式提交，所以下面要分情况讨论：默认情况下在我们注入MVC服务时被配置使用的时JsonInputFormatter，即实体默认接受JSON格式的数据，我们如果想让它接受表单数据，需要在实体前面加[FromForm].　(1).接收JSON格式：实体前面什么也不加 或者 实体前面加[FromBody]　(2).接收表单格式: 实体前面加[FromForm]注：不能分参数接收！！ 用dynamic接收的时候，只能处理前端JOSN格式的数据，加[FromBody]或者不加都行， 不能处理前端表单格式数据！！案例测试：(1). 一个参数的情况，后台分参数接收，拿不到值(2).表单提交，实体前面什么也不加 或者 实体前面加[FromForm]，Login1 和 Login2 均报415，Login3可以正常访问(3).JSON提交，实体前面加[FromBody]，Login1，Login2正常访问，Login3能访问通，但是后台拿不到值，都为空(4).JOSN格式，后台用dynamic能接收，加[FromBody]或者不加都可以接收(5).表单格式，后台用dynamic不能接收，加[FromForm]或者不加都报500，报错。\n服务端代码：\n[Route(&quot;api&#x2F;[controller]&#x2F;[action]&quot;)]\n    [ApiController]\n    public class FirstController : ControllerBase\n    &#123;\n        &#x2F;**下面是测试Post请求的相关方法**&#x2F;\n        [HttpPost]\n        public string Login0(string userName)\n        &#123;\n            return $&quot;&#123;userName&#125;&quot;;\n        &#125;\n        \n        [HttpPost]\n        public string Login1(UserInfor model)\n        &#123;\n            return $&quot;&#123;model.userName&#125;+&#123;model.pwd&#125;&quot;;\n        &#125;\n        \n        [HttpPost]\n        public string Login2([FromBody]UserInfor model)\n        &#123;\n            return $&quot;&#123;model.userName&#125;+&#123;model.pwd&#125;&quot;;\n        &#125;\n\n        [HttpPost]\n        public string Login3([FromForm]UserInfor model)\n        &#123;\n            return $&quot;&#123;model.userName&#125;+&#123;model.pwd&#125;&quot;;\n        &#125;\n        [HttpPost]\n        public string Login4([FromBody]dynamic model)\n        &#123;\n            return $&quot;&#123;model.userName&#125;+&#123;model.pwd&#125;&quot;;\n        &#125;\n\n        [HttpPost]\n        public string Login5([FromForm]dynamic model)\n        &#123;\n            return $&quot;&#123;model.userName&#125;+&#123;model.pwd&#125;&quot;;\n        &#125;\n    &#125;\n\n//二.下面是Post请求的测试\n            //（Post请求默认情况下为：ContentType = \"application/x-www-form-urlencoded\"提交表单的形式,如果要发送JOSN格式，需要加上参数contentType: 'application/json'）\n            //PS: &#123; userName: \"admin\", pwd: \"123456\" &#125; 这就是一个JSON对象，也可以叫实体\n\n            //1. 一个参数的情况，后台分参数接收,均拿不到值\n            $(\"#postBtn0\").click(function () &#123;\n                //1.1 正常拼接，可以访问通，但是拿不到userName的值\n                //$.ajax(&#123; url: \"https://localhost:44387/api/First/Login0\", type: \"Post\", data: &#123; userName: \"admin\" &#125;, success: function (data) &#123; console.log(data);  &#125; &#125;);\n                //1.2 没有键，只有值，可以访问通，但是拿不到userName的值 （这里同.Net 平台下的WebApi不同）\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login0\", type: \"Post\", data: &#123; \"\": \"admin\" &#125;, success: function (data) &#123; console.log(data); &#125; &#125;);\n            &#125;);\n\n            //2. 表单提交，Login1 和 Login2 均报415，Login3可以正常访问\n            $(\"#postBtn1\").click(function () &#123;\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login1\", type: \"Post\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, success: function (data) &#123; console.log(\"Login1:\" + data); &#125; &#125;);\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login2\", type: \"Post\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, success: function (data) &#123; console.log(\"Login2:\" + data); &#125; &#125;);\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login3\", type: \"Post\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, success: function (data) &#123; console.log(\"Login3:\" + data); &#125; &#125;);\n            &#125;);\n\n            //3.JSON提交，Login1，Login2正常访问，Login3能访问通，但是后台拿不到值，都为空\n            $(\"#postBtn2\").click(function () &#123;\n                //将post请求指定为contentType: 'application/json',且传递的参数格式化成Json字符串，则可以正常访问\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login1\", type: \"Post\", contentType: 'application/json', data: JSON.stringify(&#123; userName: \"admin\", pwd: \"123456\" &#125;), success: function (data) &#123; console.log(\"Login1:\" + data); &#125; &#125;);\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login2\", type: \"Post\", contentType: 'application/json', data: JSON.stringify(&#123; userName: \"admin\", pwd: \"123456\" &#125;), success: function (data) &#123; console.log(\"Login2:\" + data); &#125; &#125;);\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login3\", type: \"Post\", contentType: 'application/json', data: JSON.stringify(&#123; userName: \"admin\", pwd: \"123456\" &#125;), success: function (data) &#123; console.log(\"Login3:\" + data); &#125; &#125;);\n\n            &#125;);\n\n            //4.JOSN格式，后台用dynamic能接收，加[FromBody]或者不加都可以接收\n            $(\"#postBtn3\").click(function () &#123;\n                //将post请求指定为contentType: 'application/json',且传递的参数格式化成Json字符串，则可以正常访问\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login4\", type: \"Post\", contentType: 'application/json', data: JSON.stringify(&#123; userName: \"admin\", pwd: \"123456\" &#125;), success: function (data) &#123; console.log(\"JSON:\" + data); &#125; &#125;);\n            &#125;);\n            //5.表单格式，后台用dynamic不能接收，加[FromForm]或者不加都报500\n            $(\"#postBtn4\").click(function () &#123;\n                $.ajax(&#123; url: \"https://localhost:44387/api/First/Login5\", type: \"Post\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, success: function (data) &#123; console.log(\"表单:\" + data); &#125; &#125;);\n            &#125;);\n\n3. 总结\n\n\n\n\n\n\n\n\nGet请求，可以分参数接收，也可以用实体接收，需要在实体的前面加上[FromQuery]。POST请求，只能用实体接收，针对js默认的表单提交方式，实体前面加[FromForm]；针对js的JSON格式的提交方式，实体前面什么也不加 或者 实体前面加[FromBody]。\n\n4.返回值的问题用Content标记json类型和直接返回序列化字符串的区别。用 Content(jsonData, “application&#x2F;json”); 标记，前端什么不用加，可以直接点出来的。服务端代码：\n&#x2F;&#x2F;&#x2F; &lt;summary&gt;\n        &#x2F;&#x2F;&#x2F; 前端不能直接点出来\n        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;\n        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;\n        [HttpGet]\n        public string GetGoodById1()\n        &#123;\n            var myData &#x3D; new\n            &#123;\n                status &#x3D; &quot;ok&quot;,\n                goods &#x3D; new UserInfor()\n                &#123;\n                    userName &#x3D; &quot;apple&quot;,\n                    pwd &#x3D; &quot;12345&quot;\n                &#125;\n            &#125;;\n            var jsonData &#x3D; JsonConvert.SerializeObject(myData);\n            return jsonData;\n        &#125;\n\n        &#x2F;&#x2F;&#x2F; &lt;summary&gt;\n        &#x2F;&#x2F;&#x2F; 前端可以直接 点出来\n        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;\n        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;\n        [HttpGet]\n        public IActionResult GetGoodById2()\n        &#123;\n            var myData &#x3D; new\n            &#123;\n                status &#x3D; &quot;ok&quot;,\n                goods &#x3D; new UserInfor()\n                &#123;\n                    userName &#x3D; &quot;apple&quot;,\n                    pwd &#x3D; &quot;12345&quot;\n                &#125;\n            &#125;;\n            var jsonData &#x3D; JsonConvert.SerializeObject(myData);\n            return Content(jsonData, &quot;application&#x2F;json&quot;);\n        &#125;\n\n前端代码：\n$(\"#rBtn1\").click(function () &#123;\n                $.ajax(&#123;\n                    url: \"https://localhost:44387/api/First/GetGoodById1\", type: \"get\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;,  success: function (data) &#123;\n                        console.log(data);\n                        //不能直接点出来\n                        console.log(data.status);\n                    &#125;\n                &#125;);\n                $.ajax(&#123;\n                    url: \"https://localhost:44387/api/First/GetGoodById1\", type: \"get\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, dataType: \"json\", success: function (data) &#123;\n                        console.log(data);\n                        //加上dataType: \"json\",就能直接点出来\n                        console.log(data.status);\n                    &#125;\n                &#125;);\n            &#125;);\n            $(\"#rBtn2\").click(function () &#123;\n                $.ajax(&#123;\n                    url: \"https://localhost:44387/api/First/GetGoodById2\", type: \"get\", data: &#123; userName: \"admin\", pwd: \"123456\" &#125;, success: function (data) &#123;\n                        console.log(data);\n                        //能直接点出来\n                        console.log(data.status);\n                    &#125;\n                &#125;);\n            &#125;);\n\n5.特殊情况\n\n\n\n\n\n\n\n\n在Core WebApi(或Core Mvc)中，当前端发送的字段为空字符串的时候，无论get还是post请求，后端解析到的都是null，显然我们需要的不是null，而是 空字符串 “”\n解决方案：　接口用实体接收，且对应字段上加上特性　  [DisplayFormat(ConvertEmptyStringToNull &#x3D; false)]请求\n$.get(\"/api/Test1/GetGoodNum2\", &#123; id: 111, userName: \"\" &#125;, function () &#123;&#125;)\n\n接口\n[HttpGet]\npublic int GetGoodNum2([FromQuery] User user)\n&#123;\n            return user.id;\n&#125;\npublic class User\n&#123;\n        public int id &#123; get; set; &#125;\n\n        [DisplayFormat(ConvertEmptyStringToNull &#x3D; false)]\n        public string userName &#123; get; set; &#125;\n\n&#125;\n\n参考文章\nAsp.Net Core 中的模型绑定-微软官方文档\nAsp.Net Core WebApi基础总结和请求方式-博客园 \nASP.NET Core MVC 模型绑定[FromHeader]，[FromQuery]，[FromRoute]，[FromForm],[FromBody]用法场景及原理\n你所不知道的ASP.NET Core MVC&#x2F;WebApi基础系列（二）- 博客园\nASP.NET Core Web API Attributes\n\n","slug":"ASP-NET-CORE-中的模型绑定","date":"2022-05-19T02:10:11.000Z","categories_index":"","tags_index":"ASP.NET CORE C#","author_index":"好多鱼🐟"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-05-18T07:19:32.441Z","categories_index":"","tags_index":"","author_index":"好多鱼🐟"}]